# 迭代器模式(Iterator)

![web-crawler](https://tva1.sinaimg.cn/large/008i3skNgy1gwn5fpj251j30xc0godin.jpg)

网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。熟悉网络爬虫的小伙伴应该都知道，爬取网络上面存在的资源通常有两种算法：***深度遍历优先(DFS)***和***广度遍历优先(BFS)***。

* **深度遍历优先(DFS)：** 深度优先搜索策略从起始网页开始，选择一个URL进入，分析这个网页中的URL，选择一个再进入。如此一个链接一个链接地抓取下去，直到处理完一条路线之后再处理下一条路线。
* **广度遍历优先(BFS)：** 广度优先搜索策略是指在抓取过程中，在完成当前层次的搜索后，才进行下一层次的搜索。该算法的设计和实现相对简单。在目前为覆盖尽可能多的网页，一般使用广度优先搜索方法。

![BFS-DFS](https://tva1.sinaimg.cn/large/008i3skNgy1gwn5q72xp4j31l90o9gow.jpg)

除了这两种算法，可能还有最佳优先搜索等，但无论使用那种算法，最终的结果一定是将爬取到有价值的网页内容存取到某种容器(数据库、文本文件)中，然后读取这个容器中存储的网页内容即可。

![crawler-process](https://tva1.sinaimg.cn/large/008i3skNgy1gwn5s1xw4uj30me07l74y.jpg)

如果你想设计这样的一个爬虫应用程序，对于应用层来说，只需要关注如何将爬取后的结果遍历出来，而不需要关系使用了何种算法。

这里，你可以使用迭代器模式来实现这个需求。

## 模式定义

***迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。***

所以，迭代器模式给我们提供了一种需要知道容器结构的细节的情况下，遍历该容器的内部元素的能力。

对于上面使用的爬虫小程序，每一种算法使用的数据结构可能都不一样，有可能是队列，也有可能是栈，不管是那种数据结构，我们都需要对外提供一种统一的遍历最终结果的接口，这种方式屏蔽了底层实现的算法和数据结构的差异，让客户端对底层无感知的情况下操作最终额的容器。

## 模式的结构

![iterator-struction](https://tva1.sinaimg.cn/large/008i3skNgy1gwn62bemgij30qo0nwdhm.jpg)

* **迭代器(Iterator):** 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。
* **具体迭代器(Concrete Iterators):** 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。
* **容器(Collection):** 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。
* **具体集合(Concrete Collections):** 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。
* **客户端(Client):** 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。

## 模式的使用场景

* **当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。**

迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。
  
* **使用该模式可以减少程序中重复的遍历代码**
  
重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。

* **如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。**

该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。

## 模式优缺点

### 优点

* **单一职责原则:** 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。
* **开闭原则:** 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。
* **你可以并行遍历同一集合:** 因为每个迭代器对象都包含其自身的遍历状态。相似的， 你可以暂停遍历并在需要时继续

### 缺点

* 如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。
* 对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。



