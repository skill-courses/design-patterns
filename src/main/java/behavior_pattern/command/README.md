# 命令模式

当你在市中心逛了很久的街后， 突然找到了一家不错的餐厅，坐在了临窗的座位上。 

一名友善的服务员走近你，你告知了服务员自己需要点的菜名，服务员迅速记下你点的食物，写在一张纸上。 

服务员来到厨房， 把订单贴在墙上。 

过了一段时间，厨师拿到了订单，他根据订单来准备食物。 

厨师将做好的食物和订单一起放在托盘上，等待服务员端走。 

服务员看到托盘后对订单进行检查，确保所有食物都是你要的，然后将食物放到了你的桌上。

![restrant](https://tva1.sinaimg.cn/large/008i3skNly1gvry1e4bdlj30xc0goq5o.jpg)

其实，这个典型的生活场景在软件设计中属于一种经典的设计模式：**策略模式**

## 模式定义

***命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象***。 

该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

对于点菜场景来说，那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。如果在队列中的菜单还没有被厨师执行，你还可以在这个时候通知服务员取消做菜。

所以，命令模式需要`命名的创建者`，`命令对象本身`以及`命令的执行者`。 按照命令的传递顺序为：`Invoker` --> `Command` --> `Receiver`;

## 模式的结构

![command-constructor](https://tva1.sinaimg.cn/large/008i3skNly1gvryfxjkm0j30z00kkac7.jpg)

如上图所示，命令模式有以下几种角色：

* **发送者(Sender):** 亦称 “触发者（Invoker）”, 类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，而不向接收者直接发送请求。 注意，发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令。
* **命令(Command):** 接口通常仅声明一个执行命令的方法。
* **具体命令(Concrete Commands):** 会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。 但为了简化代码，这些类可以进行合并。 接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。 
* **接收者(Receiver):** 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。 
* **客户端(Client):** 会创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了。

## 模式使用场景

命名模式通常使用与如下的业务场景中：

* **如果你需要通过操作来参数化对象，可使用命令模式**

命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。

* **如果你想要将操作放入队列中、操作的执行或者远程执行操作，可使用命令模式。**

同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。

* **如果你想要实现操作回滚功能， 可使用命令模式**

尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。

## 模式的优缺点

### 优点
1. 单一职责原则。 你可以解耦触发和执行操作的类。
2. 开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。
3. 你可以实现撤销和恢复功能。
4. 你可以实现操作的延迟执行。
5. 你可以将一组简单命令组合成一个复杂命令。

### 缺点
1. 代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。
