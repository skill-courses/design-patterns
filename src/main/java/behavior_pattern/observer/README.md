# 观察者模式(Observer)

微信是一个大家普遍使用的通信工具，其中，微信公众号这个功能应该不陌生吧？相信大家至少关注过各种各样的公众号吧！公众号有个特点是，如果你关注的这个公众号有新任何更新，将会通知其所有的关注着，让关注着去查看更新。

![official-account](https://tva1.sinaimg.cn/large/008i3skNgy1gxr50zu6mtj30u01t0qac.jpg)

这在软件工程中属于一种非常典型的订阅模式，我们称为： ***观察者模式***

这种场景的典型特点在于，订阅公众号的人不需要等待公众号的更新，而是让公众号更新之后，主动通知订阅的人来获取更新，化主动为被动，通常用于异步事件的执行中。

## 模式定义

***观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。***

之所以会有这种模式，是因为将一个系统分割成一系列互相谢忠的类有一个常见的副作用：需要维护相关对象间的一致性。通常，我们不希望为了维护一致性而使得各类紧密耦合，因为这样降低了它们的可重用性。

这种模式定义了对象间的一种一对多的依赖关系，当一个对象的依赖关系发生改变时，所以依赖于它的对象都得到通知并被自动更新。Observer模式描述了如何建立这种关系。这一模式中的关键对象是**目标(subject)**和**观察者(Obsever)**.

一个目标可以有任意数目的依赖它的观察者。一点目标的状态发生改变，所有的观察者都得到通知。作为对这个通知的响应，每个观察者都将查询目标以使其状态与目标的状态同步。

这种交互方式也称为**发布--订阅(publish--subscribe)**. 目标是通知的发布者。它发出通知时并不知道谁是它的观察者。可以有任意数量的观察者订阅并接收通知。

![publish-subscribers](https://tva1.sinaimg.cn/large/008i3skNgy1gxr5pw8wczj30pk0kk0ue.jpg)

## 模式结构

![observer-structure](https://tva1.sinaimg.cn/large/008i3skNgy1gxr5tgczeqj30xw0h8mz6.jpg)

该模式主要有以下几个角色：
1. **发布者(Publisher)**: 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
2. **订阅者(Subscriber)**: 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。
3. **具体订阅者(Concrete Subscribers)**: 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。
4. **客户端(Client)**: 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。

## 使用场景

当我们遇到如下的场景时，可以考虑使用此模式：

1. 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使他们可以各自独立的改变和服用。
2. 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
3. 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。

## 优缺点

### 优点
1. 开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
2. 你可以在运行时建立对象之间的联系。

### 缺点
1. 订阅者的通知顺序是随机的。
