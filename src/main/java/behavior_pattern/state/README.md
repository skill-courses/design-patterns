# 状态模式(State)

![hair-dryer](https://tva1.sinaimg.cn/large/008i3skNgy1gxs7erbgfmj30m80bnwfs.jpg)

吹风机相信各位都使用过吧？大部分吹风机会有两个按钮，一个按钮控制开关，一个按钮控制模式，通常有热风模式、冷风模式、冷热风交替模式。工作状态如下：

* 当开关按钮处于关闭状态的时候，无法调整任何模式。
* 当打开吹风机时，默认处于热风状态。
* 热风模式可以调整为冷热风交替模式，冷热风交替模式可以调整为冷风模式，冷风模式可以调整为热风模式。
* 处于任何模式的吹风机均可直接关机。

上面的工作模式可以用下面的图例来表示：

![hair-dryer-stetes](https://tva1.sinaimg.cn/large/008i3skNgy1gxs7o0n02yj30z50tngmz.jpg)

如果你要实现这个程序，可能会通过大量的`if...else..`语句来判断各种状态直接的切换关系，这会让你的程序变得异常复杂并难以维护。

今天我们学习一种新的模式：**状态模式(state)**，来处理这种复杂的多种状态之间的切换关系。

## 模式定义

***状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。***

通常我们在以下情况下会使用状态模式：

* **如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。**

模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。

* **如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。**

状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。

* **当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。**

状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。

## 模式结构

![state-structure](https://tva1.sinaimg.cn/large/008i3skNgy1gxs83cipudj30u00ms76t.jpg)

1. **上下文(Context)**: 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。
2. **状态(State)**: 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。
3. **具体状态(Concrete States)**: 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。

状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

## 模式优缺点

### 优点
* 单一职责原则。 将与特定状态相关的代码放在单独的类中。
* 开闭原则。 无需修改已有状态类和上下文就能引入新状态。
* 通过消除臃肿的状态机条件语句简化上下文代码。

## 缺点

* 如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。