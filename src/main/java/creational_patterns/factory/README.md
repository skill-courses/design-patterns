# 工厂模式(factory Design pattern)

![phone-tablet](https://tva1.sinaimg.cn/large/008i3skNly1gy6mxkqfl7j30m80goaal.jpg)

电子产品在这个时代早就非常普遍了，大家的手机，平板，电脑等在持续的更新换代，各种品牌的手机也是层出不穷，每种品牌的电子产品在问世之前，都需要经过工厂将其生产出来。

像富士康这种代工厂几乎可以为任何品牌的任何电子产品代工，任何品牌的电子产品，只要设计出来，剩下的就交给工厂去生成，这就完事了。

这种模式在我们软件设计中属于典型的： ***工厂模式***, 工厂模式可以分为三种：**简单工厂模式(静态工厂方法)**， **工厂模式**， **抽象工厂模式**。今天我们就来逐个学习它。

## 简单工厂模式(Simple factory design pattern)

**简单工厂模式属于创建型设计模式， 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。**

严格上来说，简单工厂模式其实并不算是一种设计模式，更多的时候是一种编程习惯。之所以称之为简单工厂模式，就是因为其足够简单。这种模式所做的工作就是使用一个工厂类，将产品生产出来即可。

最大的优势就是将生产对象的职责和对象本身进行了解耦，工厂负责了产品的创建过程，客户端不需要关注产品的具体创建过程。

### 模式结构

![simple_factory_structure](https://tva1.sinaimg.cn/large/008i3skNly1gy6njp5slzj30h70ckjrv.jpg)

主要角色如下：
* **Factory**：即工厂类， 简单工厂模式的核心部分，负责实现创建所有产品的内部逻辑；工厂类可以被外界直接调用，创建所需对象
* **Product**：抽象类产品， 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象
* **ConcreteProduct**：具体产品， 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它要实现抽象产品中声明的抽象方法

### 使用场景

其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：
1. 需要创建的对象较少
2. 客户端不关心对象的创建过程。

由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；

为了解决这些缺点，就有了工厂方法模式。

## 工厂模式(Factory design pattern)





