# 原型模式(Prototype)

![sheep-duoli](https://tva1.sinaimg.cn/large/008i3skNgy1gxyj2uvhu8j30e809dt97.jpg)

很多年前，我们在初中生物课上面学习了克隆技术，知道克隆羊"多利"的诞生是克隆技术的里程碑。1996年的夏天，一只叫多莉的绵羊在苏格兰诞生了。为了培育多莉，研究人员首先从一只母羊体内取出一个卵细胞，去除它的细胞核，随后把一只6岁成年的母羊体细胞中的细胞核植入这个去核的卵细胞，最后把这个卵细胞移植到第三只羊的子宫里。5个月后多莉诞生了。它和那只提供细胞核的6岁成年母羊在遗传上是相同的，多莉是那只羊的克隆。

克隆羊"多利"是提供细胞核的甲羊的复制体，与甲羊具有完全相同的生理结构，甲羊是克隆羊"多利"的原型。在软件学中，有一种设计模式与"克隆技术"十分相似：***原型模式***

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

原型模式为此提供了一种解决方案。

## 模式定义

***原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。***

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。

所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

## 模式结构

![prototype-structure](https://tva1.sinaimg.cn/large/008i3skNgy1gxyjet52f8j30rs0m8jtg.jpg)

该结构中，相关角色如下：
1. **原型(Prototype)**: 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。
2. **具体原型(Concrete Prototype)**: 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。
3. **客户端(Client)**: 可以复制实现了原型接口的任何对象。

## 模式的使用场景

* **如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。**

* **如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。**

## 模式的优缺点

### 优点

* 你可以克隆对象， 而无需与它们所属的具体类相耦合。
* 你可以克隆预生成原型， 避免反复运行初始化代码。
* 你可以更方便地生成复杂对象。
* 你可以用继承以外的方式来处理复杂对象的不同配置。

### 缺点

* 克隆包含循环引用的复杂对象可能会非常麻烦。