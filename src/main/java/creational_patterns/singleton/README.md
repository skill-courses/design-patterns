# 单例模式(Singleton)

详细大家都对打车软件比较熟悉吧，当我们打开某滴时，首先将加载一份你所在城市的位置地图出来，然后将你定位到这个地图中。

![didi.jpg](https://tva1.sinaimg.cn/large/008i3skNgy1gxww4zqnsmj30u01qkdkp.jpg)

这个地图有个特点是：从你使用打车软件开始，直到你打车到，坐上车之后的行程，以及结束订单并退出应用程序为止，这封地图始终存在，而且还是全局唯一的一份。

这在软件设计上，我们可以使用非常经典的设计模式来实现：***单例模式(Singleton)***

## 模式定义

**单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。**

之所以会有单例模式，是因为它解决了两个常见的问题：

1. **保证一个类只有一个实例**。

为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。比如地图对于打车软件来说，只有一份不仅能够共享资源，还能够节省内存和CPU资源。

2. **为该实例提供一个全局访问节点**。

和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以保护该实例不被其他代码覆盖。例如地图在打车软件的整个生命周期中都至关重要，所有的时刻都需要访问地图这个对象，所以使用单例模式能够为其提供一个全局的访问节点。

## 模式的结构

![singleton_structure](https://tva1.sinaimg.cn/large/008i3skNgy1gxwwfbrsi9j30nw0g40tq.jpg)

上面的结构虽然比较简单，但是其实现方式多种多样，大体有7中实现，其中有5中最为常见：

### 1. [懒汉模式(线程不安全)](https://github.com/skill-courses/design-patterns/blob/main/src/main/java/creational_patterns/singleton/Singleton_01.java)

这种模式的关键点在于将构造函数申明为Private的，这样外部就不能直接访问，使用一个静态的变量在存储实例，并用一个静态的方法来初始化它。

这是一种非常经典的设计实现方案，但是其存在着线程不安全问题，当有多个线程同时访问静态方法的时候，有可能会创建多个实例出来。

### 2. [懒汉模式(线程安全)](https://github.com/skill-courses/design-patterns/blob/main/src/main/java/creational_patterns/singleton/Singleton_02.java)

这种模式的实现方式看起来和上面一种非常类似，唯一的不同之处在于，使用了关键字`synchronized`来标注静态方法，这样就可以保证线程的安全性。

但是，使用这个关键字会将此静态方法加锁，这样会导致资源的浪费和性能的下降。如果不是十分必要，不推荐使用这种模式。

### 3. [饿汉模式(线程安全)](https://github.com/skill-courses/design-patterns/blob/main/src/main/java/creational_patterns/singleton/Singleton_03.java)

这种实现模式将静态变量直接初始化一个实例对象，任何时候访问都放回这个实例。是一种非常经典而且非常简单的实现方式。

最大的问题是，这种方式会在类加载的时候去生成实例，这就会让你感觉到程序在初始化的时候非常消耗内存和性能。比如打车的软件，在启动这个应用程序的时候，就去加载地图，会让用户感觉到应用程序打开很慢。

### 4. [静态内部类(线程安全)](https://github.com/skill-courses/design-patterns/blob/main/src/main/java/creational_patterns/singleton/Singleton_04.java)

这种模式在上一种模式的基础上面，避免了饿汉模式初始化的时候消耗内存和性能，使用了内部类的模式来实现。

这是一种使用非常普遍且又非常推荐的实现模式，既保证了线程安全，有保证了懒加载，同时又不会因为加锁的方式影响性能。

### 5. [枚举实现单利(线程安全)](https://github.com/skill-courses/design-patterns/blob/main/src/main/java/creational_patterns/singleton/Singleton_05.java)

这种方式是《Effective Java》作者`Josh Bloch`提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊。

所以这种写法，是十分推荐的且是最优的, 主要是因为其他几种都无法抵御反射攻击。这种模式不仅仅有其他模式的优点，而且绝对的安全：枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。

## 模式优缺点

### 优点

1. 你可以保证一个类只有一个实例。
2. 你获得了一个指向该实例的全局访问节点。
3. 仅在首次请求单例对象时对其进行初始化。

### 缺点

1. 违反了_单一职责原则_。 该模式同时解决了两个问题。
2. 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
3. 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
4. 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。