# 装饰模式

作为程序猿的你就职于一家网络游戏公司，公司主打是一款名为《狗熊联盟》的游戏产品，在这款网络游戏中，不同的玩家可以扮演不同的"狗熊"，不同的"狗熊"还可以选择不同的"武器"来武装自己，使得自己的能力不断增强。

现在，你需要为某个名为"哪吒"的游戏角色创建多种"武器"，有"风火轮"、"混天绫"、"红缨枪"...等多种武器可以选择(购买)，当然，作为"哪吒"，如果不选择(购买)这些武器，你只能赤手空拳的和别人干架，这种情况下，你就很容易被别人秒杀，毫无游戏体验感。
如果你选择了这些武器来武装自己，你可以"脚踩风火轮"去和别人干架，战斗力迅速提升，如果你有更多的武器可以选择(有钱购买)，那么你就可以"手持红缨枪"、"脚踩风火轮"、"身披红缨枪"去和别人干架，这个时候的你战斗力爆棚，分分钟秒杀敌人，简直不要太爽。

![nezha](https://tva1.sinaimg.cn/large/008i3skNly1gt99ivibxbj31hc0k0tc0.jpg)

## 需求实现分析

针对上面的需求，最先进入大脑的是继承实现方案，你可以定一个原型的"哪吒"，然后定义"脚踩风火轮的哪吒"、"手持混天绫的哪吒"、"手持红缨枪，脚踩风火轮，身披红缨枪"的哪吒，......，这样你可以定义无数个哪吒。
上述方案虽然在功能上能够实现需求，但是众多的哪吒会让定义者和维护者头大，同时，继承的固有缺陷是，一旦继承某些父类之后，就无法对其进行移除，不得不具备继承的属性和能力，换句话说，哪吒无法对继承的技能进行选择。所以，继承的实现方案行不通。

另一种方案就是在"哪吒"的类中定义一个武器库，这个武器库可以存放各式各样的武器，用什么武器选择什么武器就可以了。这种方式可以动态的选择武器库，同时也解耦了哪吒与武器的关系。但是缺点也很明显：我们无法看出"哪吒"的成长历程以及技能的叠加效应，同时你还需要修改"哪吒"的原型类才能实现。

那该如何实现呢？这里我们推荐一种经典的设计模式：`装饰模式(decorator mode)` 来实现这个需求。

## 模式定义

**装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。**

从上面的定义我们可以看出, 装饰模式有以下特点：
* 装饰模式能够动态地将责任附加到对象上，使得对象的能力能够动态的扩展。
* 无需需求原型类：就是通过对一个类或者说对象进行装饰，而使得不修改这个类就能达到动态扩展的目的。
* 装饰模式提供了一种除继承之外的另一种选择。如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。

## 装饰模式的结构

![decorator-mode-construct](https://tva1.sinaimg.cn/large/008i3skNly1gt9aoptga1j30nz0dx75i.jpg)

上图是装饰模式的结构图，主要由以下几个重要部分：
* **部件(Component)**: 声明封装器和被封装对象的公用接口。
* **具体部件(Concrete Component)** 类是被封装对象所属的类，基本对象的原型类。它定义了基础行为，但装饰类可以改变这些行为。
* **基础装饰(Base Decorator)**： 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。
* **具体装饰类(Concrete Decorators)**: 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。

## 使用装饰模式的场景

* 如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。 
  
装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。

* 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。

当你发现继承的对象多、复杂且难以维护的时候，这种模式给你一种除了继承之外的另一种选择。

## 装饰模式的优劣

### 优势
* 你无需创建新子类即可扩展对象的行为
* 你可以在运行时添加或删除对象的功能
* 你可以用多个装饰封装对象来组合几种行为
* 单一职责原则：你可以将实现了许多不同行为的一个大类拆分为多个较小的类

### 劣势
* 在封装器栈中删除特定封装器比较困难
* 实现行为不受装饰栈顺序影响的装饰比较困难。
