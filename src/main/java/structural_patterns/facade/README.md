# 外观模式

![buy-house](https://tva1.sinaimg.cn/large/008i3skNgy1gtnmuzf1j0j61900u0wl702.jpg)

不知道各位有没有经历过二手房的买卖？如果没有，我就在这里给大家做个简单的介绍：二手房的买卖与新房的购买还是有很大的区别，新房的买卖只需要挑选好的地段和开发商，看中自己喜欢的户型，交钱买就行，剩下的流程地产商就会帮你全权搞定，你完全不用愁；
二手房的买卖完全不一样，不仅仅要考虑地段，寻找房源，看房子，与房东谈价格，签合同，房管局备案，付首付，贷款，交房等多个复杂的程序，每一个环节都有存在风险，稍有不慎，就很可能入坑。

![second-hand-house-buy-process](https://tva1.sinaimg.cn/large/008i3skNgy1gtnncohi4vj60hs11idjv02.jpg)

看完上面的流程图，相信各位都头大了，完全没有思路，慌得一批。。。

事实上，买过二手房的人都知道，虽然都需要经历这样的流程，但是却没有这么头大，其中，很重要的原因是找到了一个靠谱的中介。一家靠谱的中介非常重要，不仅能够帮自己挑选合适的房源，带看房，还能帮自己谈价，准备合同，代办一些后续的流程。
有了一个靠谱的中介，买家只需要把自己的需求提出来，然后准备好钱就行，卖家只需要将自己的房子挂牌销售即可，双方都能省不少事。

![house-agent](https://tva1.sinaimg.cn/large/008i3skNgy1gtnnrcd8krj60ci09edgo02.jpg)

所以，中介的职责是将买卖双方需要的各种流程、手续、资料等简单化，提供给了买家和卖家一个简单的"接口"，使得买卖双方都不需要太多的关注各种复杂的实施细节！这与我们软件中的一种设计模式特别相似：***外观模式(facade)***

## 模式定义

***外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。***

外观模式具有以下特点：
1. 外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。
2. 如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。

上面使用中介买房的例子中，"中介类"封装了复杂的买卖流程和各种资料的准备工作，对"买卖双方"提供了一个简单的接口，就可以实现复杂的二手房买卖流程。

## 模式的结构

![facade-constructor](https://tva1.sinaimg.cn/large/008i3skNgy1gto96w8w9lj60v40l4gnt02.jpg)

外观模式有以下几个部件：
1. **外观(Facade):** 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
2. **附加外观(Additional Facade):** 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
3. **复杂子系统(Complex Subsystem):** 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。 子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
4. **客户端(Client):** 使用外观代替对子系统对象的直接调用。

## 适用场景

1. **如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。**

子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。

2. **如果需要将子系统组织为多层结构， 可以使用外观。**
   
创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。

## 优缺点

### 优点
1. 简化客户端与复杂子系统的直接交互，让客户端的代码独立于复杂子系统。

### 缺点
1. 外观可能成为与程序中所有类都耦合的上帝对象。

在面向对象编程领域，一个上帝对象(God object)是一个了解过多或者负责过多的对象。上帝对象是反面模式的一个例子。结构化编程背后的基本概念是一个大型的问题应该被分解成为多个较小的问题中并且针对每个较小的问题提出解决方案。当每个小问题都得到解决后，大问题本体就得到了解决。因此对象应该知道的一切就是它本身。类似的，对象应该解决的问题是它所属的问题。基于上帝对象编写的代码并不遵从上述的方式。在程序设计中，避免出现上帝对象的方法有模块化和继承