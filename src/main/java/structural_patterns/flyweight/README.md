# 享元模式(flyweight)

![gobang](https://tva1.sinaimg.cn/large/008i3skNgy1gtxj9rxi1aj60fi0fidhi02.jpg)

相信各位都玩过五子棋吧？玩法非常简单，首先我们能够看到一个(15*15)
的棋盘。多个黑子和多个白子分表代表黑方和白方，黑白双方交替将棋子落在棋盘的网格交叉点上，最先在棋盘横向、竖向、斜向形成连续的相同色五个棋子的一方为胜。若棋盘在占满之前分不出胜负，则定为平局(和棋)。

现在你想用软件来实现一个在线版的五子棋小游戏，该怎么做呢？

我们可以定义一个棋盘类(ChessBoard)和一个棋子类(ChessPiece), 然后黑白双方将交替下子(New ChessPiece)。
这种方式是常用的比较简单的实现方式，但是可能会有一些问题：游戏刚刚开始的时候，运行速度很快，随着游戏的进行，运行速度变得越来越慢，如果棋盘无限大，最终有可能会让程序奔溃。。。

仔细分析这种现象，你会发现，运行内存被占满，多个棋子的重复渲染(黑白颜色在屏幕上面的渲染)占据了很大的内存，这种情况主要是由于多个棋子被重复渲染的原因。

进过分析，我们发现，不管是黑子还是白子，大部分的颜色和形状都是一样的，唯一不同的是位置信息的不同，所以，这些棋子中有些信息是可以共享的，有些信息是私有，可以进行单独设置。这就是`享元模式(flyweight)`解决的问题。

## 模式定义

***享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。***

在平常面向对象的软件开发中，偶尔会遇到这种场景，业务比较复杂，需要构建大量的对象，但是这些对象又很相似，状态变化比较小。

比如设计一款围棋游戏、丛林探险类游戏或者常见的文本处理软件，在这些场景中棋子、树木或者字符都被设计为单个对象，如果每一个对象都包含了该种类型的所有属性(例如围棋的颜色、位置属性等)，那么不可避免的系统会产生大量的相似或者相同对象。造成的后果就是系统运行代价过高，带来系统性能下降，可能引发OOM等一系列问题。

享元模式就是为了解决这类问题：需要创建大量相似对象，而又不影响开发者使用面向对象的技术操作这些对象。

所以，享元模式有以下特点：

* 需要创建大量相似的对象
* 这些对象非常相似，有很多共有属性
* 这些对象的共有属性可以共享，私有属性可以后期设置

## 模式的结构

![flyweight-constructor](https://tva1.sinaimg.cn/large/008i3skNgy1gtxmw8nkq9j60zk0loq5k02.jpg)

从上面的结构图可以看出，此模式主要包括以下几种角色：
1. **客户端(Client)**: 负责计算或存储享元的外在状态。 在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数。
2. **情景(Context)**: 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。
3. **享元(Flyweight)**: 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。
4. **享元工厂(Flyweight Factory)**: 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。

## 模式的使用场景

一般在介绍到设计模式的适用性时，只要满足适用性罗列的条件之一即可，但是享元模式比较例外，它建议当以下条件都满足时再使用。

* 一个应用使用了大量相同或者相似的对象，造成很大的内存开销；
* 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；
* 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象；

## 模式的优缺点

### 优点
* 如果程序中有很多相似对象， 那么你将可以节省大量内存。

### 缺点
* 你可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分情景数据。
* 代码会变得更加复杂。 团队中的新成员总是会问：“为什么要像这样拆分一个实体的状态？”。

